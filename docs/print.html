<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RustWHY</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="face.html"><strong aria-hidden="true">1.</strong> 封面</a></li><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">2.</strong> 首页</a></li><li class="chapter-item expanded "><a href="engineering_features/opening.html"><strong aria-hidden="true">3.</strong> 工程特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engineering_features/why_associated_type.html"><strong aria-hidden="true">3.1.</strong> 为什么要有 Associate Type？它和普通的泛型的区别是什么？</a></li></ol></li><li class="chapter-item expanded "><a href="design_choices/opening.html"><strong aria-hidden="true">4.</strong> 设计选择</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design_choices/why_not_inheritance.html"><strong aria-hidden="true">4.1.</strong> 为什么没有继承？</a></li><li class="chapter-item expanded "><a href="design_choices/why_not_global_variable.html"><strong aria-hidden="true">4.2.</strong> 为什么没有全局变量？</a></li><li class="chapter-item expanded "><a href="design_choices/why_not_overloading.html"><strong aria-hidden="true">4.3.</strong> 为什么没有重载？</a></li><li class="chapter-item expanded "><a href="design_choices/why_not_parameter_defaults.html"><strong aria-hidden="true">4.4.</strong> 为什么没有缺省参数？</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">RustWHY</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <center>
<img src="face.jpeg" alt="face" style="zoom:120%;" />
</center>
<center> Generated by <a href="orly.nanmu.me">orly.nanmu.me</a> </center>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rust-十万个为什么"><a class="header" href="#rust-十万个为什么">Rust 十万个为什么</a></h1>
<p>这里整理了一些 Rust 独特的特性，并且尝试解释为什么需要这些特性。</p>
<p>这里不回答 “Why Rust?” 而是希望汇集一些对 Rust 的思考。</p>
<h2 id="声明"><a class="header" href="#声明">声明</a></h2>
<p>这里的思考仅仅是个人的想法，不代表 Rust 官方的意见，更不代表 Rust 社区的意见。</p>
<p>权威请参见 <a href="https://rust-lang.github.io/rfcs/">Rust RFC Book</a> 以及咨询 Rust 核心开发者。</p>
<h2 id="贡献"><a class="header" href="#贡献">贡献</a></h2>
<p><a href="https://github.com/ifsheldon/RustWHY">Github Repo</a></p>
<p>如果想贡献到这个项目，你可以：</p>
<ul>
<li>写文章：请尽量有理有据。写好之后提 PR，通过之后就可以署名发表。</li>
<li>美化网站：目前我还是在用简陋的 mdbook，但是如果有人觉得不好看，可以帮忙使用更先进的前端框架美化。</li>
<li>提 Feature Request：觉得有意思的问题也可以通过提 Feature Request 的形式提问，但是也建议自己尝试搜索/探索/理解之后写文章。</li>
<li>翻译：目前仅有中文版，如果你觉得有帮助并且愿意贡献，也可以帮忙翻译成别的语言。</li>
<li>邀请大牛写文章</li>
<li>分享</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="工程特性"><a class="header" href="#工程特性">工程特性</a></h1>
<p>Rust 有很多奇特的工程特性，帮助开发者更好地写代码，同时尽量符合高质量的工程实践要求。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="为什么要有-associated-type"><a class="header" href="#为什么要有-associated-type">为什么要有 Associated Type？</a></h1>
<h2 id="背景"><a class="header" href="#背景">背景</a></h2>
<p>什么是 Associated Type？</p>
<p>Associated Type 是泛型的一个子概念。在 Rust 里 Associated Type 和 Trait 绑定在一起，指定输出类型 (output type)。</p>
<p>Rust Book 里的一个例子是：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">}
</span></code></pre></pre>
<p>这样写，<code>Counter</code>里的<code>Self::Item</code>就指代的是<code>u32</code>。</p>
<p>而更详细的介绍请看<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html">Rust Book 对应章节</a>。</p>
<h2 id="答案"><a class="header" href="#答案">答案</a></h2>
<p>短答案是：</p>
<ul>
<li>带有 Associated Type 的 Trait 只能被一个类型<code>impl</code> 一次，所以可以避免一个类型有多个<code>impl</code>。</li>
<li>Associated Type 可以当做 Output Type</li>
<li>Associated Type 带来工程上的便利</li>
</ul>
<p>如果短答案总觉得是隔靴搔痒，那么我们需要问以下子问题：</p>
<ol>
<li>既然 Associated Type 是泛型的子概念，那么 Associated Type 和 Rust 泛型有什么不同？</li>
<li>什么是 Input Type 和 Output Type？</li>
<li>为什么带有 Associated Type 的 Trait 只能被一个类型<code>impl</code> 一次？</li>
<li>普通泛型可以代替 Associated Type 吗？如果可以，那为什么还要 Associated Type？</li>
</ol>
<p>对于第一个问题，它们的不同主要有两点：</p>
<ul>
<li>
<p>普通泛型可以用于 Trait, Struct和函数，但是 Associated Type 只能与 Trait 绑定。</p>
</li>
<li>
<p>带有 Associated Type 的 Trait 只能被一个类型<code>impl</code> 一次，但是带有普通泛型的 Trait 可以有多个<code>impl</code>，例如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 普通泛型 + Trait
pub trait GiveMeSomething&lt;T: Clone&gt; {
    fn get_something(&amp;self) -&gt; T;
}

// Associated Type + Trait
pub trait GiveMeData {
    type Data;
    fn get_some_data(&amp;self) -&gt; Self::Data;
}

// 普通泛型 + Struct
pub struct Something&lt;T: Clone&gt; {
    data: T,
}

// 一个 struct 可以有多个 GiveMeSomething&lt;T&gt; 的 impl
impl&lt;T: Clone&gt; GiveMeSomething&lt;u8&gt; for Something&lt;T&gt; {
    fn get_something(&amp;self) -&gt; u8 {
        1
    }
}

impl&lt;T: Clone&gt; GiveMeSomething&lt;i32&gt; for Something&lt;T&gt; {
    fn get_something(&amp;self) -&gt; i32 {
        -1
    }
}


impl&lt;T: Clone&gt; Something&lt;T&gt; {
    // 普通泛型 + 函数
    pub fn get_data(&amp;self) -&gt; T {
        self.data.clone()
    }
}

// 一个 struct 只能有一个 GiveMeData 的 impl
impl GiveMeData for Something&lt;u8&gt; {
    type Data = u8;

    fn get_some_data(&amp;self) -&gt; Self::Data {
        self.data
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<p>如果我们把泛型的类型（也就是<code>&lt;T&gt;</code>中的<code>T</code>）也作为输入的话，那么我们可以把<code>get_data()</code>的输入看成是<code>(T, &amp;self)</code>，把它的输出看成是<code>(T, T)</code>，第一个<code>T</code>是类型，第二个<code>T</code>是指属于这个类型的值。</p>
<p>假如说我们有一个<code>Something&lt;u8&gt;</code>的示例，它存着<code>data = 1</code>，那么它的<code>get_data()</code>的输入就是<code>(u8, &amp;self)</code>，输出就是<code>(u8, 1)</code>。</p>
<p>那么，很简单的，输入的类型就是 Input Type，输出的类型就是 Output Type，也就是，出现在参数的类型是 Input Type，出现在返回值的类型是 Output Type。</p>
<p>至于第三个问题，为什么带有 Associated Type 的 Trait 只能被一个类型<code>impl</code> 一次，我们需要一些实际的例子。典型的例子就是上面的<code>pub trait Iterator</code>。对于<code>Iterator</code>，很自然的，我们想要遍历某个实例的所有的值，那么这些值只有一个类型，所以对于一个类型来说，这个 Trait 只能被<code>impl</code>一次。</p>
<p>第四个问题和第三个问题紧密相关。实际上，如果我们能人为地保证带有普通泛型的 Trait 只被一个类型 <code>impl</code> 一次，那么我们完全可以用普通泛型代替 Associated Type。那么为什么我们还要发明一个 Associated Type 呢？</p>
<p>第一个理由是最简单的，你不能人为地保证带有普通泛型的 Trait 只被一个类型 <code>impl</code> 一次。万一一个实习生不懂，为了方便就随手加多了一个<code>impl</code>呢？假如说这个乌龙发生在<code>Iterator</code>这个 Trait 上面，而恰好你也在用着它（例如<code>for item in my_custom_list {}</code>），那么<code>rustc</code>会抱怨不知道用哪个<code>impl</code>，然后一个编译错误就产生了。如果你想<code>rustc</code>帮你检查并保证这个带有普通泛型的 Trait 只被一个类型 <code>impl</code> 一次，那么这就实际上变成了 Associated Type 了。</p>
<p>更多的理由我们需要举个例子。Rust RFC Book 里的<a href="https://rust-lang.github.io/rfcs/0195-associated-items.html">例子</a>已经非常好了，所以我在这里简要翻译一下，并且补充一些内容。</p>
<p>假设我们需要建图，并且表达成一个 Trait <code>Graph</code>。如果仅仅使用普通泛型，我们可以写成</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// N 和 E 是节点和边的类型
trait Graph&lt;N, E&gt; {
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>但是如果这样写的话，一个类型可以有多个<code>Graph</code>的<code>impl</code>，并且每个<code>impl</code> 的 <code>N</code> 和 <code>E</code> 都不一样。这就有点诡异了，因为对于一个实际的图，它的节点和边的类型是唯一确定的。并且很自然地，<code>N</code>和<code>E</code>这两个类型就应该和<code>Graph</code>绑定在一起，有个从属的关系。</p>
<p>而且，假如说我们要写个函数，计算两节点间的距离，使用普通泛型，我们要这样写</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn distance&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; uint { ... }
<span class="boring">}
</span></code></pre></pre>
<p>前面泛型的部分就会有一长串，就是<code>&lt;N, E, G&lt;N, E&gt;&gt;</code>，如果一个 Trait 有好几个泛型，那么情况就更糟了，可能<code>&lt;&gt;</code>里的内容就要写一行。</p>
<p>而如果我们用 Associated Type，我们可以这样写</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Graph {
    type N;
    type E;
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p>然后计算距离的函数就可以写成</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn distance&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; uint { ... }
<span class="boring">}
</span></code></pre></pre>
<p>这样代码就变得更加简洁了。</p>
<p>另外，对比两个<code>distance</code>函数，第一个函数根本就没用到类型<code>E</code>，但是因为语法要求必须要写上，而第二个用<code>G::N</code>就行，可以不用写用不上的<code>G::E</code>。</p>
<p>除了少写用不上的代码这个好处之外，我们写代码的时候还有更多灵活性和可扩展性。假如说我们要拓展我们的<code>Graph</code>，变成</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Graph{
    type N;
    type E;
    type A;
    type B;
    type C;
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p>如果使用普通泛型的话，第一个<code>distance</code>函数就不可避免地要加上<code>A, B, C</code>这些泛型标识，否则编译就会出问题，但是使用 Associated Type 的话，第二个<code>distance</code>函数根本就不用动。</p>
<p>综上，Rust 的 Associated Type 不是普通泛型的语法糖，而是经过深思熟虑的、能够解决实际问题并且优化代码的实现。</p>
<h2 id="相关链接及参考链接"><a class="header" href="#相关链接及参考链接">相关链接及参考链接</a></h2>
<ul>
<li>Associated Type 的 <a href="https://rust-lang.github.io/rfcs/0195-associated-items.html">Rust RFC</a>，里面有更加详细的解释，并且还列举了Associated Type 另外两个优点（虽然对应用开发者影响不大）</li>
<li>Rust Forum 里的<a href="https://users.rust-lang.org/t/type-parameter-versus-type-alias-in-trait/67418">相关讨论帖子</a></li>
<li>Rust Book 里的<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html">相关章节</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="设计选择"><a class="header" href="#设计选择">设计选择</a></h1>
<p>为什么 Rust 是过程式编程语言中的清流（或者奇葩）？为什么 Rust 被称为是十多年的工程实践的结晶？</p>
<p>它的设计取舍会告诉我们（部分）答案。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="为什么没有继承"><a class="header" href="#为什么没有继承">为什么没有继承？</a></h1>
<h2 id="背景-1"><a class="header" href="#背景-1">背景</a></h2>
<p>继承常常用于面向对象的编程语言之中，通过继承，一个子类可以获得父类的部分（或全部）的属性、数据和方法。继承又可以分成单继承和多继承。例如，在 Java 中，子类只能有一个父类，所以叫单继承，而在 C++等语言中，一个子类可以有多个父类，所以叫多继承。</p>
<h2 id="答案-1"><a class="header" href="#答案-1">答案</a></h2>
<p>为什么 Rust 没有继承？</p>
<p>太长不看版就是（从<a href="https://doc.rust-lang.org/book/ch17-01-what-is-oo.html">Rust Book</a>摘录）：</p>
<ul>
<li>继承有时候会共享过多东西（如用不上的属性、数据、方法等）。有时候子类并不需要父类的所有东西（人也是一样）。</li>
<li>继承有一些问题难以解决。</li>
<li>Rust 不需要继承也可以达到类似继承的目的（代码共享、多态）。</li>
</ul>
<p>长答案就是短答案的完全展开，但是与其问为什么不要 （“Why not?”），我们先来问一下自己，为什么要（“Why?”）。</p>
<p>所以，为什么要有继承？</p>
<p>有的人说，这是面向对象编程（OOP）的特性。但是，在 Erich Gamma, Richard Helm, Ralph Johnson 和 John Vlissides (AKA gang of four) 的书《Design Patterns: Elements of Reusable Object-Oriented Software》中，他们这样定义OOP：</p>
<blockquote>
<p>Object-oriented programs are made up of objects. An <em>object</em> packages both data and the procedures that operate on that data. The procedures are typically called <em>methods</em> or <em>operations</em>.</p>
</blockquote>
<p>他们压根没提到继承。（如果有人质疑权威性的话，可以查查 Gang of Four）</p>
<p>引用 Rust Book 的观点，继承的目的只有两点：</p>
<ol>
<li>代码复用</li>
<li>多态</li>
</ol>
<p>其实多态在<strong>一定程度</strong>上也可以说是为了代码复用，所以终极的原因还是代码可复用。所以这也表现在继承的具体实现上了。通过继承，程序员可以不用写父类已经有的方法，也可以不用声明父类已经有的属性，这就让代码更加能被复用了。</p>
<p>那么看起来继承全是好处，所以程序员和继承 forever and forever 100 years!? </p>
<p>这时候学过软件工程的同学应该会搬出一个词来反驳了，那就是“耦合”(Coupling)。“耦合”说的是组件之间的依赖程度，那么，如果把父类和子类看成是两个组件，那么他们之间的耦合应该是最高的，也就是依赖程度最高。而高耦合一般是认为不好的，就不展开讲了。举个不恰当的例子，小时候买东西都要爸妈出钱，而爸妈 diss 你到了最后总是会回到一句话“你吃我的穿我的还这么不听话“，而就算占理的是你，也只能认怂。这就是高耦合的坏处🐶</p>
<p>所以顺着高耦合的坏处，我们来到了继承机制的坏处，也就是为什么不（”Why not“）。</p>
<p>首先，第一个理由就是高耦合。引申出来的问题就是，有时候子类并不需要父类的所有东西，但是继承一股脑都把父类的东西塞给子类了。大家都知道，没有免费的午餐，所以继承的东西也不是越多越好。例如，继承方法，万一子类需要写一个同名方法，但是有着不同的输入输出怎么办？有人说可以用重载，但是复杂度又增加了。</p>
<p>第二个，继承方法还有一些难堪的情形不能解决。例如，经典的圆-椭圆问题（<a href="https://en.wikipedia.org/wiki/Circle%E2%80%93ellipse_problem">Circle-Ellipse Problem</a>）。大家都知道，圆是椭圆，那么，按照继承的思路，圆就应该是椭圆的子类。同时我们知道，无论椭圆怎么在主轴上伸缩（除了零变换），它依旧是个椭圆。那么椭圆就应该有一个方法叫</p>
<p><code>Ellipse::stretch(stretch_principal_direction0:f32, stretch_principal_direction1:f32)</code></p>
<p>然而，如果圆也继承了这个方法，那么就会有圆伸缩了之后还是圆的奇怪情形。这在实践中微不足道，抛个 Exception 就完了，但是这是使用继承带来的理论上的根本问题之一。</p>
<p>第三个理由是，如果一个编程语言允许多继承，那么还会有<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">菱形继承问题</a>，这里就不展开了。</p>
<p>最后一个理由是，当继承的层级过多，记忆、管理继承下来的属性和方法就非常麻烦，使得代码更难读懂，更难理解。或许有人也曾遇到过我这样的情况，接手或学习别人的代码的时候，看到别人在代码里用了一个属性或者方法，但是在当前类中找不到，最后发现是定义在了父类中（甚至父类的父类，甚至曾祖父类中）。而如果想要定义一个子类，写一个方法，没准就是在重复造轮子，别人早早就在你继承的父类（或者祖父类，曾祖父类）中写好了，只是用了一个不同的名字。</p>
<p>另外一个，值得反思的是，为什么继承就一定会把属性和方法都继承了？属性是一个类需要的数据，方法是一个类的行为，数据和行为可能有关也可能无关，为什么要捆绑一起作为继承大礼包？</p>
<p>所以，基于上面的理由，Rust 选择完全抛开继承的概念，<strong>重新审视</strong>如何更好地复用代码。</p>
<p>首先，对于代码复用，Rust Book 中提到可以使用<code>trait</code>，因为<code>trait</code>可以有默认实现，如果不想重新写代码，那么就使用默认实现就好了。另外<code>trait</code>还可以有Super Trait（介绍见 <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait">Rust Book - super trait</a>），就可以定义<code>trait</code>之间的层级。有人说，那 Super Trait 不就是像继承了吗？这个问题我们在附录中讨论。</p>
<p>对于多态，Rust Book 里提出可以使用泛型加 Trait Bound。</p>
<blockquote>
<p>To many people, polymorphism is synonymous with inheritance. But it’s actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.</p>
<p>Rust instead uses generics to abstract over different possible types and trait bounds to impose constraints on what those types must provide. This is sometimes called <em>bounded parametric polymorphism</em>.</p>
</blockquote>
<p>也就是多态可以由泛型加上 Trait 的限制来实现。</p>
<p>需要补充的是，Rust Book 说的多态更多的是静态多态，就是编译时可以实现的多态。而如果想要实现像 Java 一样的多态（例如，向一个 Vector 里添加有着共同父类的不同子类的对象），我们需要运行时多态。而在 Rust 中，”运行时多态“是由 Dynamic Dispatch 和 <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">Trait Object</a> 实现的。</p>
<p>这样做，Rust 降低了继承的高耦合。一个类型实现一个<code>trait</code>并不会把不需要的方法也继承下来，而因为<code>trait</code>不带属性，所以也不会继承属性。</p>
<p>而没有了继承，菱形继承的数据问题当然也不复存在了。而 Super Trait 带来的方法上的菱形继承问题我们也会在附录讨论。</p>
<p>对于圆-椭圆问题，在 Rust 中<code>struct Circle</code>可以包含一个<code>Ellipse</code>的属性，但是可以选择不把一些椭圆的方法暴露出来，这就解决了圆-椭圆问题。就像这样:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ellipse{
    // zip
}
impl Ellipse{
    pub fn area(&amp;self){
        // zip
    }
    pub fn stretch(&amp;mut self){
        // zip
    }
}
pub struct Circle{
    e: Ellipse
}

impl Circle{
    pub fn area(&amp;self){
        self.e.area()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>事实上，Rust 的编程建模模式更像是组合（Composition） 而不是继承（Inheritance）。继承使用的是隐式”复制代码“，而在这个例子中，程序员要显式地在<code>Circle::area</code>中调用<code>Ellipse::area</code>。虽然多余的代码写多了一点点，但是可以清晰地指出依赖层级。</p>
<p>这样，就算 Composition 的层级再多，看代码的时候总能追踪回原来的实现，就像是上面<code>Circle::area</code>到<code>Ellipse::area</code>一样。虽然层级过多时，难以管理代码的问题依旧存在，但是至少可以减缓一点。</p>
<p>综上，Rust 抛弃了继承，选择了结合<code>trait</code>、泛型和Trait Bound 的组合（Composition）模式，解决了大部分继承带来的问题，同时尽量不引入太多的新问题、新限制，提高灵活度的同时也尽量保持了代码的可复用性。</p>
<p>有人说，有道理，但是我就想要继承，我连上面<code>Circle::area</code>这样的委托函数（delegate）都不想写，那可以怎么办？参见附录中的<code>Deref</code> Anti-pattern。</p>
<h2 id="相关链接"><a class="header" href="#相关链接">相关链接</a></h2>
<ul>
<li>Rust 社区中的讨论 <a href="https://users.rust-lang.org/t/how-to-implement-inheritance-like-feature-for-rust/31159">how to implement inheritance-like feature for rust</a></li>
<li>Rust Book相关链接，请看正文中的链接</li>
</ul>
<h2 id="附录"><a class="header" href="#附录">附录</a></h2>
<h3 id="super-trait-和继承有什么不同"><a class="header" href="#super-trait-和继承有什么不同">Super Trait 和继承有什么不同？</a></h3>
<ul>
<li>
<p>Super Trait 还是属于 Trait，所以它不能定义属性，所以也不会”继承“属性。</p>
</li>
<li>
<p>Super Trait 定义的是行为，也就是一个类型应该有的方法，由此形成的 Trait 的层级是行为上的层级。而继承不仅会继承方法，还会继承属性，引入了更多耦合，还会引入菱形继承中的数据问题。</p>
</li>
<li>
<p>虽然 super trait 同样会有菱形继承问题，但是不像数据的问题那样难以解决，方法上的冲突用<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Fully qualified syntax</a>就可以解决。例如:</p>
<pre><pre class="playground"><code class="language-rust">pub trait Say {
    fn say_something(&amp;self) {
        println!(&quot;yummy&quot;)
    }
}

pub trait EatApple: Eat + Say {
    fn eat_something(&amp;self) {
        println!(&quot;Eat something, maybe Apple?&quot;);
        self.say_something()
    }
    fn eat_apple(&amp;self) {
        println!(&quot;Eat Apple&quot;)
    }
}

pub trait EatPear: Eat + Say {
    fn eat_something(&amp;self) {
        println!(&quot;Eat something, maybe Pear?&quot;);
        self.say_something()
    }
    fn eat_pear(&amp;self) {
        println!(&quot;Eat pear&quot;)
    }
}

struct People;

impl Eat for People {}

impl Say for People {}

impl EatPear for People {}

fn main() {
    let p = People;
    Eat::eat_something(&amp;p); // OK
    p.eat_something() // compile error
}
</code></pre></pre>
</li>
</ul>
<h3 id="deref-anti-pattern"><a class="header" href="#deref-anti-pattern"><code>Deref</code> Anti-pattern</a></h3>
<p>参考自 <a href="https://rust-unofficial.github.io/patterns/anti_patterns/deref.html">Rust Design Patterns</a>。</p>
<p>太长不看版：</p>
<p>Rust 中<code>Deref</code>是这样定义的，一般用来实现智能指针，比如说<code>Box&lt;T&gt;</code>就可以实现<code>Deref</code>并且让<code>Target=T</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Deref {
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
<span class="boring">}
</span></code></pre></pre>
<p>但是既然可以随便指定<code>Target</code>，那么我们可以滥用这个来模拟继承，像这样（例子来自于参考）：</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {}

impl Foo {
    fn m(&amp;self) {
        //..
    }
}

struct Bar {
    f: Foo,
}

impl Deref for Bar {
    type Target = Foo;
    fn deref(&amp;self) -&gt; &amp;Foo {
        &amp;self.f
    }
}

fn main() {
    let b = Bar { f: Foo {} };
    b.m();
}
</code></pre></pre>
<p>那么<code>b.m()</code>就实际上是<code>b.deref().m()</code>，从而实际上实现了继承方法的作用。</p>
<p>但是这种用法属于滥用，<strong>强烈建议不要使用</strong>。在一个 <code>crate</code> 里，<code>impl</code> 和 <code>struct</code> 定义块常常可以分开，这通常问题不大，因为 IDE 可以帮忙搜索出一个类型的方法定义在哪个 <code>impl</code> 块里。然而，<code>Deref</code> 是一个微妙的语法糖，IDE 不一定能从 <code>b.m()</code> 帮忙找到 <code>Foo::m</code> ，而你可以把 <code>struct Foo</code> 和 <code>struct Bar</code> 的定义分开放并且把 <code>impl Deref for Bar</code> 代码块放在项目里十万八千里外的地方。相信没有人想遇上这样的状况，所以己所不欲勿施于人，Love and Peace❤️</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="为什么没有全局变量"><a class="header" href="#为什么没有全局变量">为什么没有全局变量？</a></h1>
<p>Coming……</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="为什么没有重载"><a class="header" href="#为什么没有重载">为什么没有重载？</a></h1>
<h2 id="背景-2"><a class="header" href="#背景-2">背景</a></h2>
<p>我们在说重载（Overloading）的时候到底在说什么？重载指的是函数重载，就是多个函数签名（Function Signature）不一样的函数可以使用同一个函数名。这个与方法重写（Method Overriding）在概念上有本质的不同。至于函数签名是什么，各个语言里重载的要求是什么，就留给感兴趣的读者自行搜索。在这里我们讨论最简单的函数重载，也就是下面的形式：</p>
<pre><code class="language-c++">int plus(int x, int y) {  // 1
  return x + y;
}

float plus(float x, float y) { // 2
  return x + y;
}

float plus(float x, float y, float z) { // 3
  return x + y;
}
</code></pre>
<p>对比 1 和 2，我们发现同名函数可以有不同的参数类型和返回值类型；对比 2 和 3，我们发现同名函数可以有不同的参数数量。</p>
<p>枚举的话，我们可以发现会用到重载的情形一共有 6 种。比如说 1 和 2 就属于情形 E，而 2 和 3 属于情形 B。</p>
<table><thead><tr><th align="center">分类</th><th align="center">参数类型</th><th align="center">参数数量</th><th align="center">返回值类型</th></tr></thead><tbody>
<tr><td align="center">A</td><td align="center">相同</td><td align="center">相同</td><td align="center">不同</td></tr>
<tr><td align="center">B</td><td align="center">相同</td><td align="center">不同</td><td align="center">相同</td></tr>
<tr><td align="center">C</td><td align="center">相同</td><td align="center">不同</td><td align="center">不同</td></tr>
<tr><td align="center">D</td><td align="center">不同</td><td align="center">相同</td><td align="center">相同</td></tr>
<tr><td align="center">E</td><td align="center">不同</td><td align="center">相同</td><td align="center">不同</td></tr>
<tr><td align="center">F</td><td align="center">不同</td><td align="center">不同</td><td align="center">相同</td></tr>
</tbody></table>
<h2 id="答案-2"><a class="header" href="#答案-2">答案</a></h2>
<h3 id="太长不看版"><a class="header" href="#太长不看版">太长不看版</a></h3>
<ul>
<li>Rust 的设计哲学之一是 Be Explicit，翻译过来就是不要藏着掖着的，越直白越好。重载违背了这一条设计哲学，所以没有引入重载。</li>
<li>一些情况下，重载的功能可以使用泛型替代，而 Rust 的 Trait 和泛型系统让去掉泛型变得容易而且更符合直觉。</li>
<li>重载可以变相实现函数参数默认值，Rust 没有引入参数默认值的特性，所以也不会有重载。</li>
<li>重载不是百利无一害的，去掉重载可以让代码变得更加容易理解。</li>
<li>重载会让 Rust 的自动类型推断出现小问题，去掉重载可以规避这些问题。</li>
</ul>
<h3 id="长答案"><a class="header" href="#长答案">长答案</a></h3>
<p>如果读者是从 Java 或者 C++之类支持函数或者方法重载的语言迁移过来的，有可能对重载已经习以为常了，甚至觉得理所当然，以致于没有思考过为什么需要重载。</p>
<p>所以，让我们扪心自问，为什么需要重载？</p>
<p>一个最简单的答案是，因为方便啊！像上面的 <code>plus</code>，我想写一个接受两个整数的版本，也写一个接受两个浮点数的版本，如果不能重载的话，那我就要写一个<code>plus_int</code>和<code>plus_float</code>，我就要记两个函数名，即使它们在本质上做的是一样的事。但是按照奥卡姆剃刀准则，“方便”并不是必要，所以 Rust 设计者完全可以“任性”去掉这个特性。</p>
<p>如果剃刀这个理由还觉得差点意思，那么我们来想想 <code>plus</code> 到底想干嘛？<code>plus</code> 有两个（双参数）实现，一个接受整数，一个接受浮点数，那么浮点数和整数的共同点是什么？它们都是数（废话）！那<code>plus</code> 的意思非常直接，就是把两个数加在一起，所以我们在 Rust 里可以这样写：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use num::Num;

fn plus&lt;T: Num&gt;(a: T, b: T) -&gt; T {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>使用泛型和 Trait Bound，我们完全可以精准表示出原来想要表达的意思，甚至还更加精确了。因为这里<code>plus</code>的意思是把两个<strong>相同</strong>类型的<strong>数</strong>相加，并且返回一个值，这个值的类型跟参数是<strong>一样的</strong>。如果是比较熟悉 Rust 类型的老油条应该还会注意到加号。加号在 Rust 里也是一个 Trait，通过实现这个 Trait 来重载加法运算符。</p>
<p>那么一个附加题就是，为什么编译器可以放行呢？也就是，我这里定义了<code>T: Num</code>，只是说明了<code>T</code> 是数字类型，但是好像没有告诉编译器<code>T</code>是可加的（实现了<code>Add</code>这个 Trait），但是为什么编译器知道 <code>T</code> 是可加的，并且加出来的结果是同一个类型的呢？</p>
<p>回归正题，举这个例子的意图是用来说明一个观点：</p>
<blockquote>
<p>Logically if we assume that function name is describing a behavior, there is no reason, that the same behavior may be performed on two completely independent, not similar types - which is what overloading actually is. If there is a situation, where operation may be performed on set of types, it‘s clear, that they have something in common, so this commonness should be extracted to trait, and then generalizing function over trait is straight way to go.</p>
<p>– Hashedone on Rust Forum</p>
</blockquote>
<p>翻译过来就是：假如我们同意函数是用来描述一个行为的，那么（在重载的情况里）一个行为竟然可以作用于完全不相干的类型，这完全没有道理。那如果这个行为可以作用于一些类型上，那么就说明这些类型是有共通之处的。那在 Rust 里表达不同类型的共通之处的方法就是 Trait，那么合理的办法就是使用泛化函数（带泛型的函数），就像 Rust 的 <code>plus</code> 那样做。这样，我们就解决了表格中的 D 和 E 两种情况。</p>
<p>而至于情况 A，两个函数输入参数相同，输入参数数量相同，只有输出类型不同，那编译器很难推导返回值类型，就会出问题。而这于常理也解释不同，为什么同一个行为，接受同样的输入，会输出不同类型的结果呢？所以以下例子应该在大多数语言里都是行不通的。</p>
<pre><code>function plus(x: float, y: float) -&gt; float{...}
function plus(x: float, y: float) -&gt; int{...}
</code></pre>
<p>而熟悉 Rust 的人应该会知道在 Rust 里也有情况 A 出现的，但是为什么编译器可以放行呢？这有两种情况，一种跟普通泛型相关，而另一种跟关联类型（Associated Type）有关（关联类型也是泛型的一种），例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = Vec::new(); // 泛型相关，现在调用的是 Vec&lt;T&gt; 的 new()，但是不知道 T 是什么类型
// let v = Vec::&lt;i8&gt;::new() // OK，编译通过，因为我们指定了使用 Vec&lt;i8&gt;的new
println!(&quot;{:?}&quot;, v);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2];
let v = a.into_iter().collect(); // 关联类型相关
// let v = let v = a.into_iter().collect::&lt;Vec&lt;_&gt;&gt;(); // OK
println!(&quot;{:?}&quot;, v);
// 感兴趣的人可以按这个路径翻一下标注库 Iterator::collect -&gt; FromIteration -&gt; IntoIterator
<span class="boring">}
</span></code></pre></pre>
<p>这里不深入讨论，这两种情况都或多或少跟以下例子的问题同源</p>
<pre><pre class="playground"><code class="language-rust">fn plus&lt;T: Num&gt;(a: T, b: T) -&gt; T {
    a + b
}
fn main() {
    let f = plus; // f 的类型是 fn(?, ?) -&gt; ? 编译器不知道? 到底是什么，所以 fn(?, ?) -&gt; ? 这个类型也是不确定的，编译出错
}
</code></pre></pre>
<p>简而言之就是纯函数的情况 A 是不允许的，因为于常理不通；而跟泛型相关的情况下，确实也会有情况 A 出现，但是这个时候跟重载没关系，那么这个时候我们可以通过特定语法，或者直接标注上变量类型来帮助类型推断器。那么情况 A 也解决了。没有重载的时候尚且会有这些小问题，如果加入重载的话那显然问题就更多了。</p>
<p>那么我们只剩下 B、C、F 这三种情况没有考虑。那么，我们什么时候会写有不同参数数量的同名函数呢？</p>
<p>一种可能是，我们想要实现默认值，用来省去复杂的配置。比如 Java 中的<code>InputStreamReader</code>的构造器，我们可以指定编码格式，或者使用默认的 UTF-8 格式。但是 Rust 不允许有默认值（为什么？请看 <a href="design_choices/why_not_parameter_defaults.html">为什么没有缺省参数</a>），所以基于不同参数数量的重载（B、C、F 三种情况）是被“不允许有默认值”这个设定一票否决了的。</p>
<p>不过还有另一种可能，我们想要可变参数数量的函数，例如 <code>print</code> 就是最常用的需求，有可能是情况 B 或者 F。情况 B 时，有同类型的输入但是不同数量，这在 Java中是用 Varargs 实现的。讲道理 Rust 也可以实现内置Varargs，比如说将多个参数放进一个数组或者 <code>Vec</code> 里，但是 It is what it is (maybe for now)。但是情况 F 是完全不可能的，因为这就代表着要将不同的类型的数据放进同一个容器中，这个是绝对不应该放进 Rust 标准库中的，但是 Rust 的 <code>println!</code>是怎么实现的呢？这好办，既然不允许函数重载，那不用函数就是了，<code>println!</code>就是一个宏，相当于是给不同的输入生成了不同的函数，这是属于元编程的暴力优雅。</p>
<p>到这，表格中的 6 种情况就讨论完了。其实除了情况 B 可以处理得更加方便之外，别的情况（A、D、E）可以使用泛型系统解决，不用引入重载，避免语言变得太繁杂，而其他情况，则是 Rust 的理念决定的，也就是越直白越好，从而就否决了函数重载，进而鼓励程序员写不同的函数名字来突出函数行为的区别。</p>
<h2 id="引用"><a class="header" href="#引用">引用</a></h2>
<ul>
<li><a href="https://users.rust-lang.org/t/is-there-a-simple-way-to-overload-functions/30937">is-there-a-simple-way-to-overload-functions</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="为什么没有缺省参数"><a class="header" href="#为什么没有缺省参数">为什么没有缺省参数？</a></h1>
<h2 id="答案很直白"><a class="header" href="#答案很直白">答案很直白</a></h2>
<ul>
<li>
<p>Rust 的设计哲学之一是 Be Explicit，翻译过来就是不要藏着掖着的，越直白越好。函数缺省参数违背了这一条设计哲学，所以没有引入。</p>
<ul>
<li>函数描述的是行为，什么样的输入会导致什么行为应该越明显越好，并且函数名与函数的输入应该直截了当地描述函数的行为。</li>
</ul>
</li>
<li>
<p>缺省参数使得数据流变得更加散乱，在工程上也有坏处。</p>
<ul>
<li>
<p>举例子，如果你尝试过看别人的 Python 代码来复现深度学习模型的话，看到无处不在的默认值肯定会非常头疼，就像下面的例子。简而言之，如果你不喜欢硬编码的绝对文件路径，那你也应该理解没有人想要看一堆全是默认值的代码。</p>
<pre><code class="language-python">def layer(x, parameter=0.1, use_branch=False):
    if use_branch:
        return some_op(x, alpha=parameter)
    else:
        return x * parameter
    
x0 = layer(y, 0.2, True)
x1 = layer(x0)
x2 = layer(x1, use_branch=False)
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="真的没有缺省值吗"><a class="header" href="#真的没有缺省值吗">真的没有缺省值吗？</a></h2>
<p>其实也是有的，对于一个<strong>类型</strong>来说，可以通过<code>impl Default</code>的方法来指定类型的实例的默认值。但是这个是非常局限的应用，看代码的人可以直接找到<code>impl</code>块获得所有的默认值信息，所以影响不大。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
