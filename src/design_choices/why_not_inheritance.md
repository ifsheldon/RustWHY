# ä¸ºä»€ä¹ˆæ²¡æœ‰ç»§æ‰¿ï¼Ÿ

## èƒŒæ™¯

ç»§æ‰¿å¸¸å¸¸ç”¨äºé¢å‘å¯¹è±¡çš„ç¼–ç¨‹è¯­è¨€ä¹‹ä¸­ï¼Œé€šè¿‡ç»§æ‰¿ï¼Œä¸€ä¸ªå­ç±»å¯ä»¥è·å¾—çˆ¶ç±»çš„éƒ¨åˆ†ï¼ˆæˆ–å…¨éƒ¨ï¼‰çš„å±æ€§ã€æ•°æ®å’Œæ–¹æ³•ã€‚ç»§æ‰¿åˆå¯ä»¥åˆ†æˆå•ç»§æ‰¿å’Œå¤šç»§æ‰¿ã€‚ä¾‹å¦‚ï¼Œåœ¨ Java ä¸­ï¼Œå­ç±»åªèƒ½æœ‰ä¸€ä¸ªçˆ¶ç±»ï¼Œæ‰€ä»¥å«å•ç»§æ‰¿ï¼Œè€Œåœ¨ C++ç­‰è¯­è¨€ä¸­ï¼Œä¸€ä¸ªå­ç±»å¯ä»¥æœ‰å¤šä¸ªçˆ¶ç±»ï¼Œæ‰€ä»¥å«å¤šç»§æ‰¿ã€‚

## ç­”æ¡ˆ

ä¸ºä»€ä¹ˆ Rust æ²¡æœ‰ç»§æ‰¿ï¼Ÿ

å¤ªé•¿ä¸çœ‹ç‰ˆå°±æ˜¯ï¼ˆä»[Rust Book](https://doc.rust-lang.org/book/ch17-01-what-is-oo.html)æ‘˜å½•ï¼‰ï¼š

* ç»§æ‰¿æœ‰æ—¶å€™ä¼šå…±äº«è¿‡å¤šä¸œè¥¿ï¼ˆå¦‚ç”¨ä¸ä¸Šçš„å±æ€§ã€æ•°æ®ã€æ–¹æ³•ç­‰ï¼‰ã€‚æœ‰æ—¶å€™å­ç±»å¹¶ä¸éœ€è¦çˆ¶ç±»çš„æ‰€æœ‰ä¸œè¥¿ï¼ˆäººä¹Ÿæ˜¯ä¸€æ ·ï¼‰ã€‚
* ç»§æ‰¿æœ‰ä¸€äº›é—®é¢˜éš¾ä»¥è§£å†³ã€‚
* Rust ä¸éœ€è¦ç»§æ‰¿ä¹Ÿå¯ä»¥è¾¾åˆ°ç±»ä¼¼ç»§æ‰¿çš„ç›®çš„ï¼ˆä»£ç å…±äº«ã€å¤šæ€ï¼‰ã€‚



é•¿ç­”æ¡ˆå°±æ˜¯çŸ­ç­”æ¡ˆçš„å®Œå…¨å±•å¼€ï¼Œä½†æ˜¯ä¸å…¶é—®ä¸ºä»€ä¹ˆä¸è¦ ï¼ˆâ€œWhy not?â€ï¼‰ï¼Œæˆ‘ä»¬å…ˆæ¥é—®ä¸€ä¸‹è‡ªå·±ï¼Œä¸ºä»€ä¹ˆè¦ï¼ˆâ€œWhy?â€ï¼‰ã€‚

æ‰€ä»¥ï¼Œä¸ºä»€ä¹ˆè¦æœ‰ç»§æ‰¿ï¼Ÿ

æœ‰çš„äººè¯´ï¼Œè¿™æ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆOOPï¼‰çš„ç‰¹æ€§ã€‚ä½†æ˜¯ï¼Œåœ¨ Erich Gamma, Richard Helm, Ralph Johnson å’Œ John Vlissides (AKA gang of four) çš„ä¹¦ã€ŠDesign Patterns: Elements of Reusable Object-Oriented Softwareã€‹ä¸­ï¼Œä»–ä»¬è¿™æ ·å®šä¹‰OOPï¼š

>Object-oriented programs are made up of objects. An *object* packages both data and the procedures that operate on that data. The procedures are typically called *methods* or *operations*.

ä»–ä»¬å‹æ ¹æ²¡æåˆ°ç»§æ‰¿ã€‚ï¼ˆå¦‚æœæœ‰äººè´¨ç–‘æƒå¨æ€§çš„è¯ï¼Œå¯ä»¥æŸ¥æŸ¥ Gang of Fourï¼‰

å¼•ç”¨ Rust Book çš„è§‚ç‚¹ï¼Œç»§æ‰¿çš„ç›®çš„åªæœ‰ä¸¤ç‚¹ï¼š

1. ä»£ç å¤ç”¨
2. å¤šæ€

å…¶å®å¤šæ€åœ¨**ä¸€å®šç¨‹åº¦**ä¸Šä¹Ÿå¯ä»¥è¯´æ˜¯ä¸ºäº†ä»£ç å¤ç”¨ï¼Œæ‰€ä»¥ç»ˆæçš„åŸå› è¿˜æ˜¯ä»£ç å¯å¤ç”¨ã€‚æ‰€ä»¥è¿™ä¹Ÿè¡¨ç°åœ¨ç»§æ‰¿çš„å…·ä½“å®ç°ä¸Šäº†ã€‚é€šè¿‡ç»§æ‰¿ï¼Œç¨‹åºå‘˜å¯ä»¥ä¸ç”¨å†™çˆ¶ç±»å·²ç»æœ‰çš„æ–¹æ³•ï¼Œä¹Ÿå¯ä»¥ä¸ç”¨å£°æ˜çˆ¶ç±»å·²ç»æœ‰çš„å±æ€§ï¼Œè¿™å°±è®©ä»£ç æ›´åŠ èƒ½è¢«å¤ç”¨äº†ã€‚

é‚£ä¹ˆçœ‹èµ·æ¥ç»§æ‰¿å…¨æ˜¯å¥½å¤„ï¼Œæ‰€ä»¥ç¨‹åºå‘˜å’Œç»§æ‰¿ forever and forever 100 years!? 

è¿™æ—¶å€™å­¦è¿‡è½¯ä»¶å·¥ç¨‹çš„åŒå­¦åº”è¯¥ä¼šæ¬å‡ºä¸€ä¸ªè¯æ¥åé©³äº†ï¼Œé‚£å°±æ˜¯â€œè€¦åˆâ€(Coupling)ã€‚â€œè€¦åˆâ€è¯´çš„æ˜¯ç»„ä»¶ä¹‹é—´çš„ä¾èµ–ç¨‹åº¦ï¼Œé‚£ä¹ˆï¼Œå¦‚æœæŠŠçˆ¶ç±»å’Œå­ç±»çœ‹æˆæ˜¯ä¸¤ä¸ªç»„ä»¶ï¼Œé‚£ä¹ˆä»–ä»¬ä¹‹é—´çš„è€¦åˆåº”è¯¥æ˜¯æœ€é«˜çš„ï¼Œä¹Ÿå°±æ˜¯ä¾èµ–ç¨‹åº¦æœ€é«˜ã€‚è€Œé«˜è€¦åˆä¸€èˆ¬æ˜¯è®¤ä¸ºä¸å¥½çš„ï¼Œå°±ä¸å±•å¼€è®²äº†ã€‚ä¸¾ä¸ªä¸æ°å½“çš„ä¾‹å­ï¼Œå°æ—¶å€™ä¹°ä¸œè¥¿éƒ½è¦çˆ¸å¦ˆå‡ºé’±ï¼Œè€Œçˆ¸å¦ˆ diss ä½ åˆ°äº†æœ€åæ€»æ˜¯ä¼šå›åˆ°ä¸€å¥è¯â€œä½ åƒæˆ‘çš„ç©¿æˆ‘çš„è¿˜è¿™ä¹ˆä¸å¬è¯â€œï¼Œè€Œå°±ç®—å ç†çš„æ˜¯ä½ ï¼Œä¹Ÿåªèƒ½è®¤æ€‚ã€‚è¿™å°±æ˜¯é«˜è€¦åˆçš„åå¤„ğŸ¶

æ‰€ä»¥é¡ºç€é«˜è€¦åˆçš„åå¤„ï¼Œæˆ‘ä»¬æ¥åˆ°äº†ç»§æ‰¿æœºåˆ¶çš„åå¤„ï¼Œä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆä¸ï¼ˆâ€Why notâ€œï¼‰ã€‚

é¦–å…ˆï¼Œç¬¬ä¸€ä¸ªç†ç”±å°±æ˜¯é«˜è€¦åˆã€‚å¼•ç”³å‡ºæ¥çš„é—®é¢˜å°±æ˜¯ï¼Œæœ‰æ—¶å€™å­ç±»å¹¶ä¸éœ€è¦çˆ¶ç±»çš„æ‰€æœ‰ä¸œè¥¿ï¼Œä½†æ˜¯ç»§æ‰¿ä¸€è‚¡è„‘éƒ½æŠŠçˆ¶ç±»çš„ä¸œè¥¿å¡ç»™å­ç±»äº†ã€‚å¤§å®¶éƒ½çŸ¥é“ï¼Œæ²¡æœ‰å…è´¹çš„åˆé¤ï¼Œæ‰€ä»¥ç»§æ‰¿çš„ä¸œè¥¿ä¹Ÿä¸æ˜¯è¶Šå¤šè¶Šå¥½ã€‚ä¾‹å¦‚ï¼Œç»§æ‰¿æ–¹æ³•ï¼Œä¸‡ä¸€å­ç±»éœ€è¦å†™ä¸€ä¸ªåŒåæ–¹æ³•ï¼Œä½†æ˜¯æœ‰ç€ä¸åŒçš„è¾“å…¥è¾“å‡ºæ€ä¹ˆåŠï¼Ÿæœ‰äººè¯´å¯ä»¥ç”¨é‡è½½ï¼Œä½†æ˜¯å¤æ‚åº¦åˆå¢åŠ äº†ã€‚

ç¬¬äºŒä¸ªï¼Œç»§æ‰¿æ–¹æ³•è¿˜æœ‰ä¸€äº›éš¾å ªçš„æƒ…å½¢ä¸èƒ½è§£å†³ã€‚ä¾‹å¦‚ï¼Œç»å…¸çš„åœ†-æ¤­åœ†é—®é¢˜ï¼ˆ[Circle-Ellipse Problem](https://en.wikipedia.org/wiki/Circleâ€“ellipse_problem)ï¼‰ã€‚å¤§å®¶éƒ½çŸ¥é“ï¼Œåœ†æ˜¯æ¤­åœ†ï¼Œé‚£ä¹ˆï¼ŒæŒ‰ç…§ç»§æ‰¿çš„æ€è·¯ï¼Œåœ†å°±åº”è¯¥æ˜¯æ¤­åœ†çš„å­ç±»ã€‚åŒæ—¶æˆ‘ä»¬çŸ¥é“ï¼Œæ— è®ºæ¤­åœ†æ€ä¹ˆåœ¨ä¸»è½´ä¸Šä¼¸ç¼©ï¼ˆé™¤äº†é›¶å˜æ¢ï¼‰ï¼Œå®ƒä¾æ—§æ˜¯ä¸ªæ¤­åœ†ã€‚é‚£ä¹ˆæ¤­åœ†å°±åº”è¯¥æœ‰ä¸€ä¸ªæ–¹æ³•å«

`Ellipse::stretch(stretch_principal_direction0:f32, stretch_principal_direction1:f32)`

ç„¶è€Œï¼Œå¦‚æœåœ†ä¹Ÿç»§æ‰¿äº†è¿™ä¸ªæ–¹æ³•ï¼Œé‚£ä¹ˆå°±ä¼šæœ‰åœ†ä¼¸ç¼©äº†ä¹‹åè¿˜æ˜¯åœ†çš„å¥‡æ€ªæƒ…å½¢ã€‚è¿™åœ¨å®è·µä¸­å¾®ä¸è¶³é“ï¼ŒæŠ›ä¸ª Exception å°±å®Œäº†ï¼Œä½†æ˜¯è¿™æ˜¯ä½¿ç”¨ç»§æ‰¿å¸¦æ¥çš„ç†è®ºä¸Šçš„æ ¹æœ¬é—®é¢˜ä¹‹ä¸€ã€‚

ç¬¬ä¸‰ä¸ªç†ç”±æ˜¯ï¼Œå¦‚æœä¸€ä¸ªç¼–ç¨‹è¯­è¨€å…è®¸å¤šç»§æ‰¿ï¼Œé‚£ä¹ˆè¿˜ä¼šæœ‰[è±å½¢ç»§æ‰¿é—®é¢˜](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem)ï¼Œè¿™é‡Œå°±ä¸å±•å¼€äº†ã€‚

æœ€åä¸€ä¸ªç†ç”±æ˜¯ï¼Œå½“ç»§æ‰¿çš„å±‚çº§è¿‡å¤šï¼Œè®°å¿†ã€ç®¡ç†ç»§æ‰¿ä¸‹æ¥çš„å±æ€§å’Œæ–¹æ³•å°±éå¸¸éº»çƒ¦ï¼Œä½¿å¾—ä»£ç æ›´éš¾è¯»æ‡‚ï¼Œæ›´éš¾ç†è§£ã€‚æˆ–è®¸æœ‰äººä¹Ÿæ›¾é‡åˆ°è¿‡æˆ‘è¿™æ ·çš„æƒ…å†µï¼Œæ¥æ‰‹æˆ–å­¦ä¹ åˆ«äººçš„ä»£ç çš„æ—¶å€™ï¼Œçœ‹åˆ°åˆ«äººåœ¨ä»£ç é‡Œç”¨äº†ä¸€ä¸ªå±æ€§æˆ–è€…æ–¹æ³•ï¼Œä½†æ˜¯åœ¨å½“å‰ç±»ä¸­æ‰¾ä¸åˆ°ï¼Œæœ€åå‘ç°æ˜¯å®šä¹‰åœ¨äº†çˆ¶ç±»ä¸­ï¼ˆç”šè‡³çˆ¶ç±»çš„çˆ¶ç±»ï¼Œç”šè‡³æ›¾ç¥–çˆ¶ç±»ä¸­ï¼‰ã€‚è€Œå¦‚æœæƒ³è¦å®šä¹‰ä¸€ä¸ªå­ç±»ï¼Œå†™ä¸€ä¸ªæ–¹æ³•ï¼Œæ²¡å‡†å°±æ˜¯åœ¨é‡å¤é€ è½®å­ï¼Œåˆ«äººæ—©æ—©å°±åœ¨ä½ ç»§æ‰¿çš„çˆ¶ç±»ï¼ˆæˆ–è€…ç¥–çˆ¶ç±»ï¼Œæ›¾ç¥–çˆ¶ç±»ï¼‰ä¸­å†™å¥½äº†ï¼Œåªæ˜¯ç”¨äº†ä¸€ä¸ªä¸åŒçš„åå­—ã€‚

å¦å¤–ä¸€ä¸ªï¼Œå€¼å¾—åæ€çš„æ˜¯ï¼Œä¸ºä»€ä¹ˆç»§æ‰¿å°±ä¸€å®šä¼šæŠŠå±æ€§å’Œæ–¹æ³•éƒ½ç»§æ‰¿äº†ï¼Ÿå±æ€§æ˜¯ä¸€ä¸ªç±»éœ€è¦çš„æ•°æ®ï¼Œæ–¹æ³•æ˜¯ä¸€ä¸ªç±»çš„è¡Œä¸ºï¼Œæ•°æ®å’Œè¡Œä¸ºå¯èƒ½æœ‰å…³ä¹Ÿå¯èƒ½æ— å…³ï¼Œä¸ºä»€ä¹ˆè¦æ†ç»‘ä¸€èµ·ä½œä¸ºç»§æ‰¿å¤§ç¤¼åŒ…ï¼Ÿ

æ‰€ä»¥ï¼ŒåŸºäºä¸Šé¢çš„ç†ç”±ï¼ŒRust é€‰æ‹©å®Œå…¨æŠ›å¼€ç»§æ‰¿çš„æ¦‚å¿µï¼Œ**é‡æ–°å®¡è§†**å¦‚ä½•æ›´å¥½åœ°å¤ç”¨ä»£ç ã€‚

é¦–å…ˆï¼Œå¯¹äºä»£ç å¤ç”¨ï¼ŒRust Book ä¸­æåˆ°å¯ä»¥ä½¿ç”¨`trait`ï¼Œå› ä¸º`trait`å¯ä»¥æœ‰é»˜è®¤å®ç°ï¼Œå¦‚æœä¸æƒ³é‡æ–°å†™ä»£ç ï¼Œé‚£ä¹ˆå°±ä½¿ç”¨é»˜è®¤å®ç°å°±å¥½äº†ã€‚å¦å¤–`trait`è¿˜å¯ä»¥æœ‰Super Traitï¼ˆä»‹ç»è§ [Rust Book - super trait](https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait)ï¼‰ï¼Œå°±å¯ä»¥å®šä¹‰`trait`ä¹‹é—´çš„å±‚çº§ã€‚æœ‰äººè¯´ï¼Œé‚£ Super Trait ä¸å°±æ˜¯åƒç»§æ‰¿äº†å—ï¼Ÿè¿™ä¸ªé—®é¢˜æˆ‘ä»¬åœ¨é™„å½•ä¸­è®¨è®ºã€‚

å¯¹äºå¤šæ€ï¼ŒRust Book é‡Œæå‡ºå¯ä»¥ä½¿ç”¨æ³›å‹åŠ  Trait Boundã€‚

>To many people, polymorphism is synonymous with inheritance. But itâ€™s actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.
>
>Rust instead uses generics to abstract over different possible types and trait bounds to impose constraints on what those types must provide. This is sometimes called *bounded parametric polymorphism*.

ä¹Ÿå°±æ˜¯å¤šæ€å¯ä»¥ç”±æ³›å‹åŠ ä¸Š Trait çš„é™åˆ¶æ¥å®ç°ã€‚

éœ€è¦è¡¥å……çš„æ˜¯ï¼ŒRust Book è¯´çš„å¤šæ€æ›´å¤šçš„æ˜¯é™æ€å¤šæ€ï¼Œå°±æ˜¯ç¼–è¯‘æ—¶å¯ä»¥å®ç°çš„å¤šæ€ã€‚è€Œå¦‚æœæƒ³è¦å®ç°åƒ Java ä¸€æ ·çš„å¤šæ€ï¼ˆä¾‹å¦‚ï¼Œå‘ä¸€ä¸ª Vector é‡Œæ·»åŠ æœ‰ç€å…±åŒçˆ¶ç±»çš„ä¸åŒå­ç±»çš„å¯¹è±¡ï¼‰ï¼Œæˆ‘ä»¬éœ€è¦è¿è¡Œæ—¶å¤šæ€ã€‚è€Œåœ¨ Rust ä¸­ï¼Œâ€è¿è¡Œæ—¶å¤šæ€â€œæ˜¯ç”± Dynamic Dispatch å’Œ [Trait Object](https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types) å®ç°çš„ã€‚

è¿™æ ·åšï¼ŒRust é™ä½äº†ç»§æ‰¿çš„é«˜è€¦åˆã€‚ä¸€ä¸ªç±»å‹å®ç°ä¸€ä¸ª`trait`å¹¶ä¸ä¼šæŠŠä¸éœ€è¦çš„æ–¹æ³•ä¹Ÿç»§æ‰¿ä¸‹æ¥ï¼Œè€Œå› ä¸º`trait`ä¸å¸¦å±æ€§ï¼Œæ‰€ä»¥ä¹Ÿä¸ä¼šç»§æ‰¿å±æ€§ã€‚

è€Œæ²¡æœ‰äº†ç»§æ‰¿ï¼Œè±å½¢ç»§æ‰¿çš„æ•°æ®é—®é¢˜å½“ç„¶ä¹Ÿä¸å¤å­˜åœ¨äº†ã€‚è€Œ Super Trait å¸¦æ¥çš„æ–¹æ³•ä¸Šçš„è±å½¢ç»§æ‰¿é—®é¢˜æˆ‘ä»¬ä¹Ÿä¼šåœ¨é™„å½•è®¨è®ºã€‚

å¯¹äºåœ†-æ¤­åœ†é—®é¢˜ï¼Œåœ¨ Rust ä¸­`struct Circle`å¯ä»¥åŒ…å«ä¸€ä¸ª`Ellipse`çš„å±æ€§ï¼Œä½†æ˜¯å¯ä»¥é€‰æ‹©ä¸æŠŠä¸€äº›æ¤­åœ†çš„æ–¹æ³•æš´éœ²å‡ºæ¥ï¼Œè¿™å°±è§£å†³äº†åœ†-æ¤­åœ†é—®é¢˜ã€‚å°±åƒè¿™æ ·:

```rust
pub struct Ellipse{
    // zip
}
impl Ellipse{
    pub fn area(&self){
        // zip
    }
    pub fn stretch(&mut self){
        // zip
    }
}
pub struct Circle{
    e: Ellipse
}

impl Circle{
    pub fn area(&self){
        self.e.area()
    }
}
```

äº‹å®ä¸Šï¼ŒRust çš„ç¼–ç¨‹å»ºæ¨¡æ¨¡å¼æ›´åƒæ˜¯ç»„åˆï¼ˆCompositionï¼‰ è€Œä¸æ˜¯ç»§æ‰¿ï¼ˆInheritanceï¼‰ã€‚ç»§æ‰¿ä½¿ç”¨çš„æ˜¯éšå¼â€å¤åˆ¶ä»£ç â€œï¼Œè€Œåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œç¨‹åºå‘˜è¦æ˜¾å¼åœ°åœ¨`Circle::area`ä¸­è°ƒç”¨`Ellipse::area`ã€‚è™½ç„¶å¤šä½™çš„ä»£ç å†™å¤šäº†ä¸€ç‚¹ç‚¹ï¼Œä½†æ˜¯å¯ä»¥æ¸…æ™°åœ°æŒ‡å‡ºä¾èµ–å±‚çº§ã€‚

è¿™æ ·ï¼Œå°±ç®— Composition çš„å±‚çº§å†å¤šï¼Œçœ‹ä»£ç çš„æ—¶å€™æ€»èƒ½è¿½è¸ªå›åŸæ¥çš„å®ç°ï¼Œå°±åƒæ˜¯ä¸Šé¢`Circle::area`åˆ°`Ellipse::area`ä¸€æ ·ã€‚è™½ç„¶å±‚çº§è¿‡å¤šæ—¶ï¼Œéš¾ä»¥ç®¡ç†ä»£ç çš„é—®é¢˜ä¾æ—§å­˜åœ¨ï¼Œä½†æ˜¯è‡³å°‘å¯ä»¥å‡ç¼“ä¸€ç‚¹ã€‚

ç»¼ä¸Šï¼ŒRust æŠ›å¼ƒäº†ç»§æ‰¿ï¼Œé€‰æ‹©äº†ç»“åˆ`trait`ã€æ³›å‹å’ŒTrait Bound çš„ç»„åˆï¼ˆCompositionï¼‰æ¨¡å¼ï¼Œè§£å†³äº†å¤§éƒ¨åˆ†ç»§æ‰¿å¸¦æ¥çš„é—®é¢˜ï¼ŒåŒæ—¶å°½é‡ä¸å¼•å…¥å¤ªå¤šçš„æ–°é—®é¢˜ã€æ–°é™åˆ¶ï¼Œæé«˜çµæ´»åº¦çš„åŒæ—¶ä¹Ÿå°½é‡ä¿æŒäº†ä»£ç çš„å¯å¤ç”¨æ€§ã€‚



æœ‰äººè¯´ï¼Œæœ‰é“ç†ï¼Œä½†æ˜¯æˆ‘å°±æƒ³è¦ç»§æ‰¿ï¼Œæˆ‘è¿ä¸Šé¢`Circle::area`è¿™æ ·çš„å§”æ‰˜å‡½æ•°ï¼ˆdelegateï¼‰éƒ½ä¸æƒ³å†™ï¼Œé‚£å¯ä»¥æ€ä¹ˆåŠï¼Ÿå‚è§é™„å½•ä¸­çš„`Deref` Anti-patternã€‚

## ç›¸å…³é“¾æ¥

* Rust ç¤¾åŒºä¸­çš„è®¨è®º [how to implement inheritance-like feature for rust](https://users.rust-lang.org/t/how-to-implement-inheritance-like-feature-for-rust/31159)
* Rust Bookç›¸å…³é“¾æ¥ï¼Œè¯·çœ‹æ­£æ–‡ä¸­çš„é“¾æ¥

## é™„å½•

### Super Trait å’Œç»§æ‰¿æœ‰ä»€ä¹ˆä¸åŒï¼Ÿ

* Super Trait è¿˜æ˜¯å±äº Traitï¼Œæ‰€ä»¥å®ƒä¸èƒ½å®šä¹‰å±æ€§ï¼Œæ‰€ä»¥ä¹Ÿä¸ä¼šâ€ç»§æ‰¿â€œå±æ€§ã€‚

* Super Trait å®šä¹‰çš„æ˜¯è¡Œä¸ºï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªç±»å‹åº”è¯¥æœ‰çš„æ–¹æ³•ï¼Œç”±æ­¤å½¢æˆçš„ Trait çš„å±‚çº§æ˜¯è¡Œä¸ºä¸Šçš„å±‚çº§ã€‚è€Œç»§æ‰¿ä¸ä»…ä¼šç»§æ‰¿æ–¹æ³•ï¼Œè¿˜ä¼šç»§æ‰¿å±æ€§ï¼Œå¼•å…¥äº†æ›´å¤šè€¦åˆï¼Œè¿˜ä¼šå¼•å…¥è±å½¢ç»§æ‰¿ä¸­çš„æ•°æ®é—®é¢˜ã€‚

* è™½ç„¶ super trait åŒæ ·ä¼šæœ‰è±å½¢ç»§æ‰¿é—®é¢˜ï¼Œä½†æ˜¯ä¸åƒæ•°æ®çš„é—®é¢˜é‚£æ ·éš¾ä»¥è§£å†³ï¼Œæ–¹æ³•ä¸Šçš„å†²çªç”¨[Fully qualified syntax](https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name)å°±å¯ä»¥è§£å†³ã€‚ä¾‹å¦‚:

    ```rust
    pub trait Say {
        fn say_something(&self) {
            println!("yummy")
        }
    }
    
    pub trait EatApple: Eat + Say {
        fn eat_something(&self) {
            println!("Eat something, maybe Apple?");
            self.say_something()
        }
        fn eat_apple(&self) {
            println!("Eat Apple")
        }
    }
    
    pub trait EatPear: Eat + Say {
        fn eat_something(&self) {
            println!("Eat something, maybe Pear?");
            self.say_something()
        }
        fn eat_pear(&self) {
            println!("Eat pear")
        }
    }
    
    struct People;
    
    impl Eat for People {}
    
    impl Say for People {}
    
    impl EatPear for People {}
    
    fn main() {
        let p = People;
        Eat::eat_something(&p); // OK
        p.eat_something() // compile error
    }
    ```

    

### `Deref` Anti-pattern

å‚è€ƒè‡ª [Rust Design Patterns](https://rust-unofficial.github.io/patterns/anti_patterns/deref.html)ã€‚

å¤ªé•¿ä¸çœ‹ç‰ˆï¼š

Rust ä¸­`Deref`æ˜¯è¿™æ ·å®šä¹‰çš„ï¼Œä¸€èˆ¬ç”¨æ¥å®ç°æ™ºèƒ½æŒ‡é’ˆï¼Œæ¯”å¦‚è¯´`Box<T>`å°±å¯ä»¥å®ç°`Deref`å¹¶ä¸”è®©`Target=T`ã€‚

```rust
pub trait Deref {
    type Target: ?Sized;
    fn deref(&self) -> &Self::Target;
}
```

ä½†æ˜¯æ—¢ç„¶å¯ä»¥éšä¾¿æŒ‡å®š`Target`ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ»¥ç”¨è¿™ä¸ªæ¥æ¨¡æ‹Ÿç»§æ‰¿ï¼Œåƒè¿™æ ·ï¼ˆä¾‹å­æ¥è‡ªäºå‚è€ƒï¼‰ï¼š

```rust
struct Foo {}

impl Foo {
    fn m(&self) {
        //..
    }
}

struct Bar {
    f: Foo,
}

impl Deref for Bar {
    type Target = Foo;
    fn deref(&self) -> &Foo {
        &self.f
    }
}

fn main() {
    let b = Bar { f: Foo {} };
    b.m();
}
```

é‚£ä¹ˆ`b.m()`å°±å®é™…ä¸Šæ˜¯`b.deref().m()`ï¼Œä»è€Œå®é™…ä¸Šå®ç°äº†ç»§æ‰¿æ–¹æ³•çš„ä½œç”¨ã€‚

ä½†æ˜¯è¿™ç§ç”¨æ³•å±äºæ»¥ç”¨ï¼Œ**å¼ºçƒˆå»ºè®®ä¸è¦ä½¿ç”¨**ã€‚åœ¨ä¸€ä¸ª `crate` é‡Œï¼Œ`impl` å’Œ `struct` å®šä¹‰å—å¸¸å¸¸å¯ä»¥åˆ†å¼€ï¼Œè¿™é€šå¸¸é—®é¢˜ä¸å¤§ï¼Œå› ä¸º IDE å¯ä»¥å¸®å¿™æœç´¢å‡ºä¸€ä¸ªç±»å‹çš„æ–¹æ³•å®šä¹‰åœ¨å“ªä¸ª `impl` å—é‡Œã€‚ç„¶è€Œï¼Œ`Deref` æ˜¯ä¸€ä¸ªå¾®å¦™çš„è¯­æ³•ç³–ï¼ŒIDE ä¸ä¸€å®šèƒ½ä» `b.m()` å¸®å¿™æ‰¾åˆ° `Foo::m` ï¼Œè€Œä½ å¯ä»¥æŠŠ `struct Foo` å’Œ `struct Bar` çš„å®šä¹‰åˆ†å¼€æ”¾å¹¶ä¸”æŠŠ `impl Deref for Bar` ä»£ç å—æ”¾åœ¨é¡¹ç›®é‡Œåä¸‡å…«åƒé‡Œå¤–çš„åœ°æ–¹ã€‚ç›¸ä¿¡æ²¡æœ‰äººæƒ³é‡ä¸Šè¿™æ ·çš„çŠ¶å†µï¼Œæ‰€ä»¥å·±æ‰€ä¸æ¬²å‹¿æ–½äºäººï¼ŒLove and Peaceâ¤ï¸

